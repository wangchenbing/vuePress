---
title: 构造函数与原型链
date: 2022-7-18
---
## 什么是构造函数

```jsx
function Person(name,age){
  this.name = name;
  this.age = age;
}
var obj = new Person('zs',12);
```

构造函数是一个特殊的函数,用来初始化对象,为对象成员变量赋初始值,需要和new一起使用

new步骤:

> 1.内存中创建一个空对象
>
>2.我们将这个空对象的proto成员指向了构造函数对象prototype成员
>
>3.我们将构造函数对象的this指针代替成空对象,然后在调用构造函数,于是构造的this就指向了新的空对象,
  并且会往实例化对象身上挂在方法
>
>4.返回实例化对象

## 静态成员和实例成员

> 静态成员：在构造函数本身上添加的成员静态成员只能通过构造函数来访问
> 
> 实例成员：在构造函数内部通过this添加的成员 实例成员只能通过实例化的对象来访问

## 构造函数原型prototype

>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。

## 对象原型

> 对象都会有一个属性.__ *proto__*指向构造函数的prototype原型对象,之所以我们对象可以使用构造函数prototype
   原型对象的属性和方法,就是因为对象有__proto__原型的存在.
> 
> __proto__对象原型和原型对象prototype是等价的
> 
> __proto__对象原型的意义就在于为对象的查找机制提供一个方向,或者说是一条线路,但是他是一个非标准属性,
  因此实际开发中,不可以使用这个属性,他只是内部指向原型对象,prototype

![对象原型.png](./img/duixiangyuanxing.png)

```jsx
    function Star(uname, age) {
      this.uname = uname;
      this.age = age;
    }
    Star.prototype.sing = function () {
      console.log('我会唱歌');
    }
    //实例对象是构造函数所
    const ldh = new Star('刘德华', 13);// 构造函数的实例对象
    const zxy = new Star('张学友', 15);
    ldh.sing()
    console.log(ldh);
    console.log(ldh.__proto__ === Star.prototype);//true
    console.log(ldh.__proto__); // 实例的__proto__指向构造函数的原型对象
    console.log(Star.prototype);// 构造函数的prototpye指向构造函数的原型对象
```

## constructor 构造函数

对象原型(__proto__)和构造函数(prototype)原型对象里面都有一个属性constructor属性,constructor我们称为构造函数,因为它指回构造函数本身.

constructor主要用于记录改对象引用哪个构造函数,他可以让原型对象重新指向原来的构造函数.

**为什么需要指向原来的构造函数**

但是如果方法比较多的话，大多人会采用一种更简洁的方法：直接使用一个对象字面形式替换原型对象，如下：

```jsx
Person.prototype = {
  sing: function () {
    console.log('sing')
  },
  movie: function () {
    console.log('movie')
  }
}
var obj = new Person('zs', 12);
console.log(obj.constructor===Person)//false
console.log(obj.constructor===Object)//true
```

使用字面量形式改写了原型对象改变了构造函数的属性，因此他指向Object而不是Person.这是因为原型对象具有一个constructor属性，这是其他对象实例所没有的。当一个函数被创建时，它的prototype属性也被创建，且该原型对象的constructor属性指向该函数。当使用对象字面量形式改写原型对象时，其constructor属性将被置为泛用对象Object.为了避免这一点，需要在改写原型对象的时候手动重置constructor,如下：

```jsx
Person.prototype = {
  constructor: Person,
  sing: function () {
    console.log('sing')
  },
  movie: function () {
    console.log('movie')
  }
}
var obj = new Person('zs', 12);
console.log(obj.constructor===Person)//true
console.log(obj.constructor===Object)//false
```

如果我们修改了原来的原型对象,给原型对象赋值的事一个对象,则必须手动的利用constructor指回原来的构造函数

```jsx
 function Star(uname, age) {
     this.uname = uname;
     this.age = age;
 }
 // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数
 Star.prototype = {
 // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
   constructor: Star, // 手动设置指回原来的构造函数
   sing: function() {
     console.log('我会唱歌');
   },
   movie: function() {
     console.log('我会演电影');
   }
}
var zxy = new Star('张学友', 19);
console.log(zxy)
```

## 原型链

每个实例对象又有一个proto属性,指向的构造函数的原型对象,构造函数的原型对象也是一个对象,也有proto属性,这样一层一层往上找就形成了原型链

![原型链.png](./img/yuanxinglian.png)

## 构造函数实例和对象三角关系

1. 构造函数的prototype属性指向了构造函数原型对象
2. 实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象
3. 构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数

![构造函数实例和对象三角关系.png](./img/sanjiaoguanxi.png)

## 原型对象中的this指向

构造函数中的this和原型对象中的this,都指向我们new出来的实例对象

```jsx
  function Star(uname, age) {
      this.uname = uname;
      this.age = age;
  }
  var that;
  Star.prototype.sing = function() {
      console.log('我会唱歌');
      that = this;
  }
  var ldh = new Star('刘德华', 18);
  // 1. 在构造函数中,里面this指向的是对象实例 ldh
  console.log(that === ldh);//true
  // 2.原型对象函数里面的this 指向的是 实例对象 ldh
```